/**
 * ============================================================
 * VibeGo Kiosk - Ana Program
 * Platform: Waveshare ESP32-S3-Touch-LCD-5B
 * Display: 1024x600 RGB Landscape Mode
 * 
 * Features:
 * - WiFi AP+STA Mode (Always accessible via AP)
 * - Web Dashboard for all settings
 * - HTTP OTA Updates
 * - Manual Brightness (Web control)
 * - Sensor Simulation Mode
 * ============================================================
 */

#include <Arduino.h>
#include <lvgl.h>
#include <esp_task_wdt.h>
#include <ESP_Panel_Library.h>
#include "ui/ui.h"
#include "wifi_handler.h"
#include "http_ota.h"
#include "brightness.h"
#include "ntp_time.h"
#include "data_logger.h"
#include "web_server.h"
#include "webhook_logger.h"
#include "sponsor_manager.h"

// ============================================================
// Firmware Version
// ============================================================
#define FIRMWARE_VERSION "1.4.0"

// ============================================================
// Display Configuration (Waveshare 5B)
// ============================================================
#define DISPLAY_WIDTH  1024
#define DISPLAY_HEIGHT 600
// No rotation needed, RGB panel is already landscape

// ============================================================
// Sensor Simulation
// ============================================================
#define SENSOR_SIMULATION_ENABLED true
#define SIMULATION_DURATION_MS 4000
#define BAC_THRESHOLD 0.50f

// ============================================================
// Global Objects
// ============================================================
static ESP_Panel *panel = nullptr;
static lv_disp_draw_buf_t draw_buf;

// LVGL buffer - using PSRAM for large 1024x600 display
// Buffer size: Full Frame (1024 * 600 * 2 bytes = 1.2MB)
// Double buffering in PSRAM for smooth animations
static lv_color_t *buf1 = nullptr;
static lv_color_t *buf2 = nullptr;
// Note: We will alloc full size in setup


// Simulation state
static bool is_measuring = false;
static uint32_t measurement_start_time = 0;

// ============================================================
// Brightness Callback (Manual via web panel)
// ============================================================
void set_display_brightness(int level) {
    // TODO: Implement backlight control via CH422G IO expander
    // For now, brightness is handled by web panel
    Serial.printf("Brightness level: %d\n", level);
}

// ============================================================
// LVGL Display Flush Callback (ESP_Panel)
// ============================================================
void my_disp_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p) {
    if (panel && panel->getLcd()) {
        panel->getLcd()->drawBitmap(area->x1, area->y1, area->x2 + 1, area->y2 + 1, color_p);
    }
    lv_disp_flush_ready(disp_drv);
}

// ============================================================
// LVGL Touch Read Callback (GT911)
// ============================================================
void my_touchpad_read(lv_indev_drv_t *indev_drv, lv_indev_data_t *data) {
    if (panel && panel->getLcdTouch()) {
        panel->getLcdTouch()->readData();
        bool touched = panel->getLcdTouch()->getTouchState();
        
        if (touched) {
            TouchPoint point = panel->getLcdTouch()->getPoint(0);
            data->state = LV_INDEV_STATE_PRESSED;
            data->point.x = point.x;
            data->point.y = point.y;
        } else {
            data->state = LV_INDEV_STATE_RELEASED;
        }
    } else {
        data->state = LV_INDEV_STATE_RELEASED;
    }
}

// ============================================================
// Sensor Simulation
// ============================================================
float generate_random_bac() {
    randomSeed(analogRead(0) + millis());
    int chance = random(100);
    
    if (chance < 70) {
        return (float)random(0, 50) / 100.0f;
    } else {
        return (float)random(50, 200) / 100.0f;
    }
}

void start_measurement_simulation() {
    if (!SENSOR_SIMULATION_ENABLED) return;
    is_measuring = true;
    measurement_start_time = millis();
    Serial.println("[SIM] Measurement started...");
}

void update_measurement_simulation() {
    if (!is_measuring) return;
    
    uint32_t elapsed = millis() - measurement_start_time;
    int progress = (elapsed * 100) / SIMULATION_DURATION_MS;
    if (progress > 100) progress = 100;
    
    extern lv_obj_t * ui_Measuring_Progress;
    if (ui_Measuring_Progress != NULL) {
        lv_bar_set_value(ui_Measuring_Progress, progress, LV_ANIM_ON);
    }
    
    if (elapsed >= SIMULATION_DURATION_MS) {
        is_measuring = false;
        float bac = generate_random_bac();
        bool is_safe = bac < BAC_THRESHOLD;
        
        Serial.printf("[SIM] BAC = %.2f (%s)\n", bac, is_safe ? "Safe" : "Danger");
        
        // Log the test result
        logger_add_test(bac, is_safe);
        
        if (bac < 0.50) {
            ui_show_result_safe(bac);
        } else {
            ui_show_result_danger(bac);
        }
        
        lv_bar_set_value(ui_Measuring_Progress, 0, LV_ANIM_OFF);
    }
}

void screen_load_event_cb(lv_event_t * e) {
    lv_obj_t * scr = lv_event_get_target(e);
    extern lv_obj_t * ui_Measuring;
    if (scr == ui_Measuring) {
        start_measurement_simulation();
    }
}

// ============================================================
// Serial Command Handler
// ============================================================
void handle_serial_commands() {
    if (Serial.available()) {
        String cmd = Serial.readStringUntil('\n');
        cmd.trim();
        
        if (cmd == "wifi_reset") {
            Serial.println("[CMD] Resetting WiFi...");
            wifi_reset();
        }
        else if (cmd == "wifi_scan") {
            Serial.println("[CMD] Scanning networks...");
            int count = wifi_scan_networks();
            Serial.printf("[CMD] Found %d networks\n", count);
        }
        else if (cmd == "wifi_ap") {
            Serial.println("[CMD] Restarting AP...");
            wifi_restart_ap();
        }
        else if (cmd == "reboot") {
            Serial.println("[CMD] Rebooting...");
            ESP.restart();
        }
        else if (cmd == "status") {
            Serial.println("=== STATUS ===");
            Serial.printf("Firmware: v%s\n", http_ota_get_version());
            Serial.printf("AP Active: %s\n", wifi_is_ap_active() ? "Yes" : "No");
            if (wifi_is_ap_active()) {
                Serial.printf("AP IP: %s\n", wifi_get_ap_ip().c_str());
                int remaining = wifi_get_ap_remaining_seconds();
                if (remaining > 0) {
                    Serial.printf("AP Remaining: %d min %d sec\n", remaining / 60, remaining % 60);
                } else {
                    Serial.printf("AP Remaining: Unlimited (waiting for connection)\n");
                }
            }
            Serial.printf("STA Status: %s\n", wifi_get_status_str());
            if (wifi_is_connected()) {
                Serial.printf("STA SSID: %s\n", wifi_get_ssid().c_str());
                Serial.printf("STA IP: %s\n", wifi_get_sta_ip().c_str());
                Serial.printf("Signal: %d%%\n", wifi_get_signal_percent());
            }
            Serial.printf("Brightness: %d (Auto: %s)\n", brightness_get_level(), brightness_is_auto() ? "Yes" : "No");
            Serial.printf("LDR Raw: %d\n", brightness_get_ldr_raw());
        }
        else if (cmd == "update" || cmd == "ota") {
            Serial.println("[CMD] Checking for updates...");
            http_ota_force_update();
        }
        else if (cmd == "version") {
            Serial.printf("Firmware: v%s\n", http_ota_get_version());
        }
        else if (cmd == "help") {
            Serial.println("=== COMMANDS ===");
            Serial.println("status      - Show system status");
            Serial.println("update/ota  - Check and install updates");
            Serial.println("version     - Show firmware version");
            Serial.println("wifi_scan   - Scan WiFi networks");
            Serial.println("wifi_ap     - Restart AP mode (30 min)");
            Serial.println("wifi_reset  - Reset WiFi credentials");
            Serial.println("reboot      - Restart device");
            Serial.println("dashboard   - Show web panel URL");
        }
        else if (cmd == "dashboard") {
            Serial.printf("AP Dashboard: http://%s/\n", wifi_get_ap_ip().c_str());
            if (wifi_is_connected()) {
                Serial.printf("STA Dashboard: http://%s/\n", wifi_get_sta_ip().c_str());
            }
        }
    }
}

// ============================================================
// Setup
// ============================================================
void setup() {
    // 1. Initialize Watchdog (60s timeout, NO PANIC) to prevent resets during debug
    // This will allow us to see if loop freezes without rebooting
    esp_task_wdt_init(60, false);
    
    Serial.begin(115200);
    delay(500);
    
    Serial.println();
    Serial.println("╔════════════════════════════════════════╗");
    Serial.println("║      VIBEGO - AlkoMetric Kiosk         ║");
    Serial.printf("║      Firmware: v%s                  ║\n", FIRMWARE_VERSION);
    Serial.println("║      Platform: Waveshare ESP32-S3-5B  ║");
    Serial.println("║      Display: 1024x600 RGB            ║");
    Serial.println("║      Mode: AP + STA                    ║");
    Serial.println("╚════════════════════════════════════════╝");
    Serial.println();

    // 2. Initialize ESP_Panel (Display + Touch)
    Serial.print("[INIT] ESP_Panel...");
    panel = new ESP_Panel();
    panel->init();
    panel->begin();
    Serial.println(" OK");
    
    Serial.println("[INIT] Brightness: Manual control via web");

    // 3. Initialize LVGL Core
    Serial.print("[INIT] LVGL...");
    lv_init();
    
    // 4. Allocate Full Frame Buffers in PSRAM (1.2MB each)
    // 4. Allocate Partial Draw Buffers in INTERNAL RAM
    // Reduced to 20 lines to prevent OOM (Out Of Memory) crashes
    // 1024 * 20 * 2 bytes = ~40KB per buffer. Total ~80KB. Safe for WiFi + System.
    int buffer_lines = 20; 
    uint32_t buf_size = DISPLAY_WIDTH * buffer_lines;
    Serial.printf("[INIT] Allocating Internal SRAM buffers: 2 x %d lines (~%d KB)...\n", buffer_lines, (buf_size * 2) / 1024);
    
    // Use MALLOC_CAP_INTERNAL | MALLOC_CAP_DMA to ensure it's DMA capable
    buf1 = (lv_color_t *)heap_caps_malloc(buf_size * sizeof(lv_color_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_DMA);
    buf2 = (lv_color_t *)heap_caps_malloc(buf_size * sizeof(lv_color_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_DMA);
    
    if (!buf1 || !buf2) {
        Serial.println(" FAILED (Internal SRAM allocation)");
        Serial.println("Trying smaller buffer (10 lines)...");
        if (buf1) free(buf1);
        if (buf2) free(buf2);
        
        // Fallback: 10 lines
        buffer_lines = 10;
        buf_size = DISPLAY_WIDTH * buffer_lines;
        buf1 = (lv_color_t *)heap_caps_malloc(buf_size * sizeof(lv_color_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_DMA);
        buf2 = (lv_color_t *)heap_caps_malloc(buf_size * sizeof(lv_color_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_DMA);
    }
    
    Serial.printf("[INIT] Buffer1 Addr: %p, Buffer2 Addr: %p\n", buf1, buf2);
    // On ESP32-S3, Internal SRAM is usually below 0x3C000000
    if ((uint32_t)buf1 < 0x3C000000) Serial.println("[INFO] Buffer1 is in Internal RAM (Optimal for performace)");
    else Serial.println("[WARN] Buffer1 is in PSRAM (May cause flickering)");
    
    lv_disp_draw_buf_init(&draw_buf, buf1, buf2, buf_size);
    
    // 5. Register Display Driver
    static lv_disp_drv_t disp_drv;
    lv_disp_drv_init(&disp_drv);
    disp_drv.hor_res = DISPLAY_WIDTH;
    disp_drv.ver_res = DISPLAY_HEIGHT;
    disp_drv.flush_cb = my_disp_flush;
    disp_drv.draw_buf = &draw_buf;
    disp_drv.full_refresh = 0; // Use partial refresh with double buffer
    lv_disp_drv_register(&disp_drv);
    Serial.println(" OK");
    
    // 6. Register Touch Driver
    Serial.print("[INIT] Touch...");
    static lv_indev_drv_t indev_drv;
    lv_indev_drv_init(&indev_drv);
    indev_drv.type = LV_INDEV_TYPE_POINTER;
    indev_drv.read_cb = my_touchpad_read;
    lv_indev_drv_register(&indev_drv);
    Serial.println(" OK");

    // 7. Initialize UI
    Serial.print("[INIT] UI...");
    ui_init();
    Serial.println(" OK");

    // Setup screen event for simulation
    // DISABLED: ui_Measuring is NULL until first created (on-demand)
    // extern lv_obj_t * ui_Measuring;
    // lv_obj_add_event_cb(ui_Measuring, screen_load_event_cb, LV_EVENT_SCREEN_LOADED, NULL);

    // 8. Initialize WiFi (AP+STA mode)
    Serial.println("[INIT] WiFi AP+STA...");
    wifi_init(true);
    
    // Initialize NTP (if connected to external network)
    if (wifi_is_connected()) {
        ntp_init();
    }
    
    // 9. Initialize Services
    Serial.print("[INIT] Logger...");
    if (logger_init()) {
        Serial.println(" OK");
    } else {
        Serial.println(" FAILED");
    }
    
    web_server_init();
    
    sponsor_init();
    String savedQrUrl = sponsor_get_qr_url();
    String savedQrTitle = sponsor_get_qr_title();
    ui_update_qr_code(savedQrUrl.c_str());
    ui_update_qr_title(savedQrTitle.c_str());
    Serial.printf("[INIT] Sponsor: %s (%s)\n", savedQrTitle.c_str(), savedQrUrl.c_str());
    
    if (wifi_is_connected()) {
        webhook_init();
    }
    
    // 10. WDT is initialized at start (30s)
    // No need to add loop task manually in Arduino
    
    Serial.println();
    Serial.println("[READY] System started!");
    Serial.println("[INFO] Type 'help' for commands");
    Serial.printf("[WEB] AP Dashboard: http://%s/\n", wifi_get_ap_ip().c_str());
    if (wifi_is_connected()) {
        Serial.printf("[WEB] STA Dashboard: http://%s/\n", wifi_get_sta_ip().c_str());
    }
    Serial.println();
}

// ============================================================
// Main Loop
// ============================================================
void loop() {
    uint32_t loop_start = millis();
    
    // Reset Watchdog Timer
    esp_task_wdt_reset();
    
    // LVGL
    lv_timer_handler();
    
    // WiFi status update
    wifi_update();
    
    // Delayed init: Start services when WiFi connects to external network
    static bool sta_services_started = false;
    if (!sta_services_started && wifi_is_connected()) {
        ntp_init();
        webhook_init();
        sta_services_started = true;
        Serial.println("[INIT] STA services started (NTP, Webhook)");
    }
    
    // NTP sync update (non-blocking)
    ntp_update();
    
    // HTTP OTA (GitHub - check every hour, only if connected to internet)
    if (wifi_is_connected()) {
        http_ota_check_periodic();
    }
    
    // Brightness (auto LDR)
    brightness_update();
    
    // Webhook queue sync check (only if connected)
    if (wifi_is_connected()) {
        webhook_update();
    }
    
    // Sensor simulation
    if (SENSOR_SIMULATION_ENABLED) {
        update_measurement_simulation();
    }
    
    // Serial commands
    handle_serial_commands();
    
    // System Health Monitor (Every 10 seconds)
    static uint32_t last_monitor = 0;
    if (millis() - last_monitor > 10000) {
        last_monitor = millis();
        Serial.printf("[SYS] Free Heap: %d KB | Min Heap: %d KB | PSRAM: %d KB\n", 
            esp_get_free_heap_size() / 1024, 
            esp_get_minimum_free_heap_size() / 1024,
            heap_caps_get_free_size(MALLOC_CAP_SPIRAM) / 1024);
            
        if (!wifi_is_connected()) {
            Serial.println("[WARN] WiFi Disconnected!");
        }
    }
    
    // Loop Latency Warning
    uint32_t loop_duration = millis() - loop_start;
    if (loop_duration > 50) {
        Serial.printf("[WARN] Loop took %d ms! (Possible UI Lag)\n", loop_duration);
    }
    
    delay(5);
}
